const { deepObjectIgnoreNullValues, matchSpace } = require("./helpers");
const {
  prettyJSON,
  containsCheck,
  containsKeys,
  keys,
  eachKey,
  transpose,
  deepEqual,
  isString,
} = require("lazy-z");
const {
  tfxModuleRegExp,
  extraWhitespaceRegExp,
  newLineBeforeNextBlockRegExp,
  spacesBeforeOpenBraces,
  extraNewlinesRegExp,
  endingNewlinesRegExp,
  parsedJsonStringMissingFrontQuoteExp,
} = require("./constants");
const YAML = require("json-to-pretty-yaml");
const tfCli = require("./terraform-cli");
const yaml = require("js-yaml");
const { textTemplate } = require("./builders");
const {
  formatResourceName,
  formatResourceAddress,
  formatModuleName,
  formatModuleYamlOutput,
  indent,
} = require("./text-replacements");
const { RegexButWithWords } = require("regex-but-with-words");

const resourceTemplate = new textTemplate(
  `tfx.resource(\n  "$RESOURCE_NAME",\n  '$RESOURCE_ADDRESS',\n$VALUES\n),`
);
const moduleTemplate = new textTemplate(
  `\n\ntfx.module(\n  "$MODULE_NAME",\n  '$MODULE_ADDRESS',\n$VALUES\n);`
);
const testTemplate = new textTemplate(
  `// This file was generated by tfxjs\nconst tfxjs = require("tfxjs");\nconst tfx = new tfxjs(\n  "$TEMPLATE_PATH",\n  $TF_VARS\n);\n\ntfx.plan("$TEMPLATE_NAME", () => {\n$MODULE_DATA\n});\n`
);

const stateTemplate = new textTemplate(
  `tfx.address($RESOURCE_ADDRESS, $VALUES\n`
);

const moduleStateTemplate = new textTemplate(
  `tfx.state($MODULE_NAME,\n$VALUES\n`
);

/**
 * Extract a resource test from json data
 * @param {Object} resource Terraform resource object
 * @param {string} resource.name Resource name
 * @param {string} resource.address Resource address
 * @param {Object} resource.values Resource Values
 * @param {string} outputType Can be `tfx` or `yaml`
 * @param {boolean} includeNull Include null values
 * @param {number} spaces Spaces to prepend to result
 * @returns {string} Resource data string
 */
function planResourceTest(resource, outputType, includeNull, spaces, shallow) {
  containsCheck("planResourceTest only accepts", ["tfx", "yaml"], outputType);
  if (deepEqual(resource, { timeouts: null })) return "";
  // get resource name and address after returning timeouts block
  let resourceName = formatResourceName(resource);
  let resourceAddress = formatResourceAddress(resource);

  // List of values
  let values = includeNull
    ? resource.values // if include null, return values
    : deepObjectIgnoreNullValues(resource.values, shallow); // otherwise deep ignorenull
  if (outputType === "tfx") {
    return resourceTemplate
      .clone()
      .fill(
        resourceName,
        resourceAddress,
        matchSpace(spaces || 1, prettyJSON(values))
      );
  } else {
    let objectArrayValues = []; // Change into array for yaml readability
    // For each key
    eachKey(values, (key) => {
      objectArrayValues.push({
        // Add a single object to the array with only the key and the value
        [key]: values[key],
      });
    });
    // return yaml
    return {
      [resourceName]: {
        address: resourceAddress,
        values: objectArrayValues,
      },
    };
  }
}

/**
 * Get tests for a module inside tfplan
 * @param {Object} tfModule terraform module
 * @param {string} outputType Can be tfx or yaml
 * @param {boolean} includeNull Include null values
 * @param {boolean} isSubModule Prevent recursive callbacks from stringifying yaml
 * @returns Data for module test
 */
function moduleTest(tfModule, outputType, includeNull, isSubModule, shallow) {
  let resources = []; // Resources
  if (containsKeys(tfModule, "root_module")) {
    tfModule = tfModule.root_module;
    tfModule.address = "root_module";
  }
  // Format module name from address
  let moduleName = formatModuleName(tfModule.address);

  // For each resource, add a test to resources
  if (containsKeys(tfModule, "resources"))
    tfModule.resources.forEach((resource) => {
      resources.push(
        planResourceTest(resource, outputType, includeNull, 0, shallow)
      );
    });

  // Data to output
  let outputData =
    outputType === "yaml" && resources.length > 0
      ? // Output type is yaml set as object
        {
          [moduleName]: {
            address: tfModule.address,
            resources: resources,
          },
        }
      : outputType === "yaml"
      ? {} // prevent from returning modules with no resources
      : moduleTemplate
          .clone()
          .fill(
            moduleName,
            tfModule.address,
            matchSpace(1, resources.length === 0 ? "{}" : resources.join("\n"))
          );

  if (outputType !== "yaml" && outputData.match(tfxModuleRegExp)) {
    outputData = "";
  }
  // If child modules exist
  if (containsKeys(tfModule, "child_modules")) {
    // For each child
    tfModule.child_modules.forEach((child) => {
      // Extract module data for child modules
      // if type is yaml don't stringify data
      let childData = moduleTest(
        child,
        outputType,
        includeNull,
        outputType === "yaml" ? true : isSubModule
      );
      if (outputType === "tfx") {
        let extactedData = moduleTest(
          child,
          outputType,
          includeNull,
          isSubModule,
          shallow
        );
        // If tfx add string
        outputData += "\n" + extactedData;
      } else {
        // If yaml add as key
        transpose(childData, outputData);
      }
    });
  }

  if (typeof outputData === "string")
    outputData = outputData
      .replace(extraWhitespaceRegExp, "\n")
      .replace(newLineBeforeNextBlockRegExp, ";\n\n");
  // If is submodule or tfx, return raw output, otherwise yaml stringify data
  return isSubModule || outputType === "tfx"
    ? outputData
    : formatModuleYamlOutput(outputData);
}

/**
 * Callback for planTfx
 * @param {string} type yaml or tfx
 * @param {boolean} shallow preserve shallow null values from terraform plan
 * @param {string} templatePath Relative template path
 * @param {string} templateName Name of the template
 * @param {Object} tfvars Arbitrarty tfvars
 * @param {extractCallback} callback Callback function
 * @returns
 */
function fileDataCallback(
  type,
  shallow,
  templatePath,
  templateName,
  tfvars,
  callback
) {
  return function (planData) {
    let planModules = moduleTest(planData, type, false, false, shallow);
    if (type === "yaml") {
      planModules =
        YAML.stringify({
          tfxPlan: {
            "template-path": templatePath,
            "template-name": templateName,
            tfvars: tfvars,
          },
        }) + planModules;
    }
    callback(
      type === "tfx"
        ? testTemplate
            .clone()
            .fill(
              templatePath,
              prettyJSON(tfvars),
              templateName,
              matchSpace(1, planModules)
            )
        : planModules
    );
  };
}

/**
 * Create a tfx test file and return data
 * @param {string} templateName Name of the template
 * @param {string} templatePath Relative template path
 * @param {Object} tfvars Arbitrarty tfvars
 * @param {Promise} exec Promisify exec
 * @param {boolean} shallow preserve shallow null values from terraform plan
 * @param {boolean} quiet disable logs
 * @param {extractCallback} callback Callback function
 * @returns {Promise} terraform plan promise
 */
function planTfx(
  templateName,
  templatePath,
  type,
  tfvars,
  exec,
  shallow,
  quiet,
  callback
) {
  let cli = new tfCli(templatePath, exec, !quiet);
  return cli
    .plan(
      tfvars,
      fileDataCallback(
        type,
        shallow,
        templatePath,
        templateName,
        tfvars,
        callback
      ),
      { cleanup: true }
    )
    .catch(cli.tfErr);
}

/**
 * @callback extractCallback
 * @param {string} fileData
 */
function deyamilfy(yamlFileData, tfvars) {
  // Load file
  let jsonData = yaml.load(yamlFileData);
  // String Data
  let strData = "";
  // Clone of test text template
  let jsTestTemplate = testTemplate.clone();
  let overrideTfvars = tfvars || {}; // Set override tfvars to empty object if not passed
  // For each key in the returned data
  eachKey(jsonData, (key) => {
    if (key !== "tfxPlan") {
      // If the key is not tfxPlan
      let newModule = moduleTemplate.clone(); // Create new module template
      newModule.set("$MODULE_NAME", key); // Set name
      newModule.set("$MODULE_ADDRESS", jsonData[key].address); // Set address
      let resources = []; // List of found resources
      // For each resource
      jsonData[key].resources.forEach((resource) => {
        let newResource = resourceTemplate.clone(); // create a new resource template
        let resourceName = keys(resource)[0]; // get first key
        let resourceAddress = resource[resourceName].address; // get address
        let valuesArr = resource[resourceName].values; // get values
        let valueObject = {}; // values object
        // For each value set that value on values object
        valuesArr.forEach((value) => {
          let valueKey = keys(value)[0];
          valueObject[valueKey] = value[valueKey];
        });
        // Add to list of resources the new template with data
        resources.push(
          newResource.fill(
            resourceName,
            resourceAddress,
            matchSpace(1, prettyJSON(valueObject))
          )
        );
      });
      // Set module values to equal resources joined by new line
      newModule.set("$VALUES", matchSpace(1, resources.join("\n")));
      strData += "\n" + newModule.str; // Add module to string data for return
    } else {
      let tfxTemplateData = jsonData[key]; // Get template data
      // set template path
      jsTestTemplate.set(
        "$TEMPLATE_PATH",
        tfxTemplateData["template-path"] || "<template path>"
      );
      // set template name
      jsTestTemplate.set(
        "$TEMPLATE_NAME",
        tfxTemplateData["template-name"] || "<template name>"
      );
      // if contains tfvars
      if (containsKeys(tfxTemplateData, "tfvars")) {
        // for each key
        eachKey(tfxTemplateData.tfvars, (key) => {
          // if not already in tfvars, replace
          if (!containsKeys(overrideTfvars, key)) {
            overrideTfvars[key] = tfxTemplateData.tfvars[key];
          }
        });
      }
      // Set tfvars to override
      jsTestTemplate.set(
        "$TF_VARS",
        // Match spaces and replace leading spaces before tfvar opening brace with spaces for formatting
        matchSpace(1, prettyJSON(overrideTfvars)).replace(
          spacesBeforeOpenBraces,
          ""
        )
      );
    }
  });
  strData = strData
    .replace(extraNewlinesRegExp, "\n") // Replace extra newlines
    .replace(endingNewlinesRegExp, ";\n\n"); // Add newlines at the end of blocks
  return jsTestTemplate.set("$MODULE_DATA", matchSpace(1, strData));
}

/**
 * apply resource test
 * @param {object} resource
 * @returns {string} text test
 */
function applyResourceTest(resource) {
  let instancesText = "";
  let address = stateTemplate.clone();
  let onlyOneInstance = resource.instances.length === 1;
  address.set("$RESOURCE_ADDRESS", formatResourceAddress(resource));
  for (let i = 0; i < resource.instances.length; i++) {
    let attributes = resource.instances[i].attributes;
    // add index key from instance if not a number
    if (containsKeys(resource.instances[i], "index_key")) {
      if (isString(resource.instances[i].index_key)) {
        attributes.index_key = resource.instances[i].index_key;
      }
    }
    instancesText += indent(prettyJSON(attributes), onlyOneInstance ? 0 : 2);
    if (i !== resource.instances.length - 1) {
      instancesText += ",\n";
    }
  }
  instancesText =
    instancesText
      .replace(/ +(?={)/i, "") // remove trailing spaces before object open
      .replace(/ (?=}$)/i, "") // remove indents before last brace and close expression
      .replace(/"(?=\b[^:\n,]+:)/g, "") // remove opening quotes of object before colon
      .replace(/":/g, ":") // replace quote colon
      .replace(parsedJsonStringMissingFrontQuoteExp, ': "') // replace unclosed string values taken away with JSON.parse
      .replace(/:\{/g, ": {") + ");";
  let tfxAddress = address.set("$VALUES", instancesText);
  if (!onlyOneInstance) {
    tfxAddress = tfxAddress
      .replace(/",\s\{\n/i, '",\n  {\n') // replace opening instance brace with formatted one
      .replace("});", " }\n)"); // format closing brace
  }
  return tfxAddress;
}

/**
 * create a state resource test for a module
 * @param {string} moduleName module name
 * @param {Array<object>} moduleData list of arrays in the module
 * @returns {string} formatted address
 */
function stateResourceTest(moduleName, moduleData) {
  let text = moduleStateTemplate.clone();
  let addressTests = "";
  for (let i = 0; i < moduleData.length; i++) {
    addressTests += indent(applyResourceTest(moduleData[i]), 2)
      .replace(/\s+(?=$)/g, "") // remove spaces leading to return
      .replace(/;/g, ","); // replace ending semicolon with comma
    if (moduleData.length !== 1 && i + 1 !== moduleData.length) {
      addressTests += "\n";
    }
  }
  addressTests += "\n);";
  return text
    .fill(`"${moduleName}"`, addressTests)
    .replace(/\)\s+(?=tfx.address)/g, "),\n  "); // add retroactive commas between address resources
}

/**
 * create apply tfx
 * @param {object} tfState terraform state file
 * @param {Function} writeFileCallBack write file callback
 */
function applyTfx(tfState, statePath, writeFileCallBack) {
  let moduleMap = {
    root_module: [],
  };
  let applyText = `// This file was generated by tfxjs
const tfxjs = require("tfxjs");
const tfx = new tfxjs("${statePath}");

tfx.apply("tfxjs generated tests", () => {\n  `;
  tfState.resources.forEach((resource) => {
    if (containsKeys(moduleMap, resource.module)) {
      moduleMap[resource.module].push(resource);
    } else if (resource.module) {
      moduleMap[resource.module] = [resource];
    } else {
      moduleMap.root_module.push(resource);
    }
  });
  eachKey(moduleMap, (moduleName) => {
    applyText += indent(
      stateResourceTest(moduleName, moduleMap[moduleName]),
      2
    ).replace(/\s+(?=tfx.state)/g, "");
  });
  let finishedText = applyText.replace(/\s+(?=$)/g, "\n});\n");
  if (writeFileCallBack) {
    writeFileCallBack(finishedText);
  } else return finishedText;
}

module.exports = {
  planResourceTest,
  moduleTest,
  fileDataCallback,
  planTfx,
  deyamilfy,
  applyResourceTest,
  stateResourceTest,
  applyTfx,
};
