const {
  capitalizeWords,
  deepObjectIgnoreNullValues,
  matchSpace,
  formatModuleName,
} = require("./helpers");
const {
  prettyJSON,
  containsCheck,
  containsKeys,
  keys,
  eachKey,
  transpose,
} = require("./utils");
const YAML = require("json-to-pretty-yaml");
const tfCli = require("./terraform-cli");
const yaml = require("js-yaml");
const { textTemplate } = require("./builders");

const resourceTemplate = new textTemplate(
  `tfx.resource(\n  "$RESOURCE_NAME",\n  '$RESOURCE_ADDRESS',\n$VALUES\n),`
);
const moduleTemplate = new textTemplate(
  `\n\ntfx.module(\n  "$MODULE_NAME",\n  '$MODULE_ADDRESS',\n$VALUES\n);`
);
const testTemplate = new textTemplate(
  `// This file was generated by tfxjs\nconst tfxjs = require("tfxjs");\nconst tfx = new tfxjs(\n  "$TEMPLATE_PATH",\n  $TF_VARS\n);\n\ntfx.plan("$TEMPLATE_NAME", () => {\n$MODULE_DATA\n});\n`
);

const extract = {
  /**
   * Extract a resource test from json data
   * @param {Object} resource Terraform resource object
   * @param {string} resource.name Resource name
   * @param {string} resource.address Resource address
   * @param {Object} resource.values Resource Values
   * @param {string} outputType Can be `tfx` or `yaml`
   * @param {boolean} includeNull Include null values
   * @param {number} spaces Spaces to prepend to result
   * @returns {string} Resource data string
   */
  planResourceTest: function (
    resource,
    outputType,
    includeNull,
    spaces,
    shallow
  ) {
    containsCheck("planResourceTest only accepts", ["tfx", "yaml"], outputType);
    // Add index to name if resource has index
    let indexName =
      resource.name +
      (containsKeys(resource, "index") ? " " + resource.index : "");
    let resourceName = capitalizeWords(indexName.replace(/(_|-)/g, " ")); // Resource name
    let resourceAddress =
      (resource.mode === "data" ? "data." : "") +
      resource.address.replace(/.+\.(?=.+\..+)/g, "").replace(/\"/g, '\\"'); // Resource Address
    // List of values
    let values = includeNull
      ? resource.values // if include null, return values
      : deepObjectIgnoreNullValues(resource.values, shallow); // otherwise deep ignorenull

    if (outputType === "tfx") {
      return resourceTemplate
        .clone()
        .fill(
          resourceName,
          resourceAddress,
          matchSpace(spaces || 1, prettyJSON(values))
        );
    } else {
      let objectArrayValues = []; // Change into array for yaml readability
      // For each key
      eachKey(values, (key) => {
        objectArrayValues.push({
          // Add a single object to the array with only the key and the value
          [key]: values[key],
        });
      });
      // return yaml
      return {
        [resourceName]: {
          address: resourceAddress,
          values: objectArrayValues,
        },
      };
    }
  },

  /**
   * Get tests for a module inside tfplan
   * @param {Object} tfModule terraform module
   * @param {string} outputType Can be tfx or yaml
   * @param {boolean} includeNull Include null values
   * @param {boolean} isSubModule Prevent recursive callbacks from stringifying yaml
   * @returns Data for module test
   */
  moduleTest: function (
    tfModule,
    outputType,
    includeNull,
    isSubModule,
    shallow
  ) {
    let resources = []; // Resources
    if (containsKeys(tfModule, "root_module")) {
      tfModule = tfModule.root_module;
      tfModule.address = "root_module";
    }
    // Format module name from address
    let moduleName = formatModuleName(tfModule.address);

    // For each resource, add a test to resources
    if (containsKeys(tfModule, "resources"))
      tfModule.resources.forEach((resource) => {
        resources.push(
          extract.planResourceTest(
            resource,
            outputType,
            includeNull,
            0,
            shallow
          )
        );
      });

    // Data to output
    let outputData =
      outputType === "yaml" && resources.length > 0
        ? // Output type is yaml set as object
          {
            [moduleName]: {
              address: tfModule.address,
              resources: resources,
            },
          }
        : outputType === "yaml"
        ? {} // prevent from returning modules with no resources
        : moduleTemplate
            .clone()
            .fill(
              moduleName,
              tfModule.address,
              matchSpace(
                1,
                resources.length === 0 ? "{}" : resources.join("\n")
              )
            );
    if (
      outputType !== "yaml" &&
      outputData.match(/tfx.module\(\s+\".+\",\s+\'.+\',\s+\{\}\s+\);/g)
    ) {
      outputData = "";
    }
    // If child modules exist
    if (containsKeys(tfModule, "child_modules")) {
      // For each child
      tfModule.child_modules.forEach((child) => {
        // Extract module data for child modules
        // if type is yaml don't stringify data
        let childData = extract.moduleTest(
          child,
          outputType,
          includeNull,
          outputType === "yaml" ? true : isSubModule
        );
        if (outputType === "tfx") {
          let extactedData = extract.moduleTest(
            child,
            outputType,
            includeNull,
            isSubModule,
            shallow
          );
          // If tfx add string
          outputData += "\n" + extactedData;
        } else {
          // If yaml add as key
          transpose(childData, outputData);
        }
      });
    }

    if (typeof outputData === "string")
      outputData = outputData
        .replace(/\n\s*\n+/g, "\n")
        .replace(/;\n(?=tfx)/g, ";\n\n");

    // If is submodule or tfx, return raw output, otherwise yaml stringify sata
    return isSubModule || outputType === "tfx"
      ? outputData
      : "\n" +
          YAML.stringify(outputData)
            .replace(/(?<=\s)"(?=\w)|(?<=\w|\d|\])"(?=\n)|(\\\\)/g, "") // remove quotes around string type variables and also escaped slashes
            .replace(/\\\"/g, '"'); // replace escaped quotes with single quotes
  },

  /**
   * Callback for planTfx 
   * @param {string} type yaml or tfx
   * @param {boolean} shallow preserve shallow null values from terraform plan
   * @param {string} templatePath Relative template path
   * @param {string} templateName Name of the template
   * @param {Object} tfvars Arbitrarty tfvars
   * @param {*} callback Callback function
   * @returns 
   */
  fileDataCallback: (
    type,
    shallow,
    templatePath,
    templateName,
    tfvars,
    callback
  ) => {
    return (planData) => {
      let planModules = extract.moduleTest(
        planData,
        type,
        false,
        false,
        shallow
      );
      if (type === "yaml") {
        planModules =
          YAML.stringify({
            tfxPlan: {
              "template-path": templatePath,
              "template-name": templateName,
              tfvars: tfvars,
            },
          }) + planModules;
      }
      callback(type === "tfx"
        ? testTemplate
            .clone()
            .fill(
              templatePath,
              prettyJSON(tfvars),
              templateName,
              matchSpace(1, planModules)
            )
        : planModules);
    };
  },

  /**
   * Create a tfx test file and return data
   * @param {string} templateName Name of the template
   * @param {string} templatePath Relative template path
   * @param {Object} tfvars Arbitrarty tfvars
   * @param {Promise} exec Promisify exec
   * @param {boolean} shallow preserve shallow null values from terraform plan
   * @param {boolean} quiet disable logs
   * @param {extractCallback} callback Callback function
   */
  planTfx: function (
    templateName,
    templatePath,
    type,
    tfvars,
    exec,
    shallow,
    quiet,
    callback
  ) {
    let cli = new tfCli(templatePath, exec, !quiet);
    return cli
      .plan(
        tfvars,
        extract.fileDataCallback(
          type,
          shallow,
          templatePath,
          templateName,
          tfvars,
          callback
        ),
        { cleanup: true }
      )
      .catch(cli.tfErr);
  },
  /**
   * @callback extractCallback
   * @param {string} fileData
   */

  deyamilfy: function (yamlFileData, tfvars) {
    // Load file
    let jsonData = yaml.load(yamlFileData);
    // String Data
    let strData = "";
    // Clone of test text template
    let jsTestTemplate = testTemplate.clone();
    let overrideTfvars = tfvars || {}; // Set override tfvars to empty object if not passed
    // For each key in the returned data
    eachKey(jsonData, (key) => {
      if (key !== "tfxPlan") {
        // If the key is not tfxPlan
        let newModule = moduleTemplate.clone(); // Create new module template
        newModule.set("$MODULE_NAME", key); // Set name
        newModule.set("$MODULE_ADDRESS", jsonData[key].address); // Set address
        let resources = []; // List of found resources
        // For each resource
        jsonData[key].resources.forEach((resource) => {
          let newResource = resourceTemplate.clone(); // create a new resource template
          let resourceName = keys(resource)[0]; // get first key
          let resourceAddress = resource[resourceName].address; // get address
          let valuesArr = resource[resourceName].values; // get values
          let valueObject = {}; // values object
          // For each value set that value on values object
          valuesArr.forEach((value) => {
            let valueKey = keys(value)[0];
            valueObject[valueKey] = value[valueKey];
          });
          // Add to list of resources the new template with data
          resources.push(
            newResource.fill(
              resourceName,
              resourceAddress,
              matchSpace(1, prettyJSON(valueObject))
            )
          );
        });
        // Set module values to equal resources joined by new line
        newModule.set("$VALUES", matchSpace(1, resources.join("\n")));
        strData += "\n" + newModule.str; // Add module to string data for return
      } else {
        let tfxTemplateData = jsonData[key]; // Get template data
        // set template path
        jsTestTemplate.set(
          "$TEMPLATE_PATH",
          tfxTemplateData["template-path"] || "<template path>"
        );
        // set template name
        jsTestTemplate.set(
          "$TEMPLATE_NAME",
          tfxTemplateData["template-name"] || "<template name>"
        );
        // if contains tfvars
        if (containsKeys(tfxTemplateData, "tfvars")) {
          // for each key
          eachKey(tfxTemplateData.tfvars, (key) => {
            // if not already in tfvars, replace
            if (!containsKeys(overrideTfvars, key)) {
              overrideTfvars[key] = tfxTemplateData.tfvars[key];
            }
          });
        }
        // Set tfvars to override
        jsTestTemplate.set(
          "$TF_VARS",
          // Match spaces and replace leading spaces before tfvar opening brace with spaces for formatting
          matchSpace(1, prettyJSON(overrideTfvars)).replace(/\s\s(?=\{)/i, "")
        );
      }
    });
    strData = strData
      .replace(/\n\s*\n+/g, "\n") // Replace extra newlines
      .replace(/;\n(?=tfx)/g, ";\n\n"); // Add newlines at the end of blocks
    return jsTestTemplate.set("$MODULE_DATA", matchSpace(1, strData));
  },
};

module.exports = extract;
