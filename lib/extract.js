const {
  capitalizeWords,
  deepObjectIgnoreNullValues,
  matchSpace,
  formatModuleName,
} = require("./helpers");
const {
  prettyJSON,
  containsCheck,
  containsKeys,
  keys,
  eachKey,
  transpose,
} = require("./utils");
const YAML = require("json-to-pretty-yaml");
const tfCli = require("./terraform-cli");
const yaml = require("js-yaml");
const { textTemplate } = require("./builders");

const resourceTemplate = new textTemplate(
  `tfx.resource(\n  "$RESOURCE_NAME",\n  '$RESOURCE_ADDRESS',\n$VALUES\n),`
);
const moduleTemplate = new textTemplate(
  `\n\ntfx.module(\n  "$MODULE_NAME",\n  '$MODULE_ADDRESS',\n$VALUES\n);`
);
const testTemplate = new textTemplate(
  `// This file was generated by tfxjs\nconst tfxjs = require("tfxjs");\nconst tfx = new tfxjs(\n  "$TEMPLATE_PATH",\n  $TF_VARS\n);\n\ntfx.plan("$TEMPLATE_NAME", () => {\n$MODULE_DATA\n});\n`
);

const extract = {
  /**
   * Extract a resource test from json data
   * @param {Object} resource Terraform resource object
   * @param {string} resource.name Resource name
   * @param {string} resource.address Resource address
   * @param {Object} resource.values Resource Values
   * @param {string} outputType Can be `tfx` or `yaml`
   * @param {boolean} includeNull Include null values
   * @param {number} spaces Spaces to prepend to result
   * @returns {string} Resource data string
   */
  planResourceTest: function (resource, outputType, includeNull, spaces) {
    containsCheck("planResourceTest only accepts", ["tfx", "yaml"], outputType);
    // Add index to name if resource has index
    let indexName =
      resource.name +
      (containsKeys(resource, "index") ? " " + resource.index : "");
    let resourceName = capitalizeWords(indexName.replace(/(_|-)/g, " ")); // Resource name
    let resourceAddress = resource.address
      .replace(/.+\.(?=.+\..+)/g, "")
      .replace(/\"/g, '\\"'); // Resource Address
    // List of values
    let values = includeNull
      ? resource.values // if include null, return values
      : deepObjectIgnoreNullValues(resource.values); // otherwise deep ignorenull

    if (outputType === "tfx") {
      return resourceTemplate
        .clone()
        .fill(
          resourceName,
          resourceAddress,
          matchSpace(spaces || 1, prettyJSON(values))
        );
    } else {
      let objectArrayValues = []; // Change into array for yaml readability
      // For each key
      eachKey(values, (key) => {
        objectArrayValues.push({
          // Add a single object to the array with only the key and the value
          [key]: values[key],
        });
      });
      // return yaml
      return {
        [resourceName]: {
          address: resourceAddress,
          values: objectArrayValues,
        },
      };
    }
  },

  /**
   * Get tests for a module inside tfplan
   * @param {Object} tfModule terraform module
   * @param {string} outputType Can be tfx or yaml
   * @param {boolean} includeNull Include null values
   * @param {boolean} isSubModule Prevent recursive callbacks from stringifying yaml
   * @returns Data for module test
   */
  moduleTest: function (tfModule, outputType, includeNull, isSubModule) {
    let resources = []; // Resources
    if (containsKeys(tfModule, "root_module")) {
      tfModule = tfModule.root_module;
      tfModule.address = "root_module";
    }
    // Format module name from address
    let moduleName = formatModuleName(tfModule.address);

    // For each resource, add a test to resources
    if (containsKeys(tfModule, "resources"))
      tfModule.resources.forEach((resource) => {
        resources.push(
          extract.planResourceTest(resource, outputType, includeNull, 0)
        );
      });

    // Data to output
    let outputData =
      outputType === "yaml" && resources.length > 0
        ? // Output type is yaml set as object 
          {
            [moduleName]: {
              address: tfModule.address,
              resources: resources,
            },
          }
        : outputType === "yaml"
        ? {} // prevent from returning modules with no resources
        : moduleTemplate
            .clone()
            .fill(
              moduleName,
              tfModule.address,
              matchSpace(
                1,
                resources.length === 0 ? "{}" : resources.join("\n")
              )
            );
    if (
      outputType !== "yaml" &&
      outputData.match(/tfx.module\(\s+\".+\",\s+\'.+\',\s+\{\}\s+\);/g)
    ) {
      outputData = "";
    }
    // If child modules exist
    if (containsKeys(tfModule, "child_modules")) {
      // For each child
      tfModule.child_modules.forEach((child) => {
        // Extract module data for child modules
        // if type is yaml don't stringify data
        let childData = extract.moduleTest(
          child,
          outputType,
          includeNull,
          outputType === "yaml" ? true : isSubModule
        );
        if (outputType === "tfx") {
          let extactedData = extract.moduleTest(child, outputType, includeNull);
          // If tfx add string
          outputData += "\n" + extactedData;
        } else {
          // If yaml add as key
          transpose(childData, outputData);
        }
      });
    }

    if (typeof outputData === "string")
      outputData = outputData
        .replace(/\n\s*\n+/g, "\n")
        .replace(/;\n(?=tfx)/g, ";\n\n");

    // If is submodule or tfx, return raw output, otherwise yaml stringify sata
    return isSubModule || outputType === "tfx"
      ? outputData
      : "\n" + YAML.stringify(outputData);
  },

  /**
   * Create a tfx test file and return data
   * @param {string} templateName Name of the template
   * @param {string} templatePath Relative template path
   * @param {Object} tfvars Arbitrarty tfvars
   * @param {Promise} exec Promisify exec
   * @param {extractCallback} callback Callback function
   */
  planTfx: async function (
    templateName,
    templatePath,
    type,
    tfvars,
    exec,
    callback
  ) {
    let cli = new tfCli(templatePath, exec, false);
    await cli.plan(
      tfvars,
      (planData) => {
        let planModules = extract.moduleTest(planData, type);
        callback(
          type === "tfx"
            ? testTemplate
                .clone()
                .fill(
                  templatePath,
                  prettyJSON(tfvars),
                  templateName,
                  matchSpace(1, planModules)
                )
            : planModules
        );
      },
      { cleanup: true }
    );
  },
  /**
   * @callback extractCallback
   * @param {string} fileData
   */

  deyamilfy: function (yamlFileData) {
    let jsonData = yaml.load(yamlFileData);
    let strData = "";
    eachKey(jsonData, (key) => {
      let newModule = moduleTemplate.clone();
      newModule.set("$MODULE_NAME", key);
      newModule.set("$MODULE_ADDRESS", jsonData[key].address);
      let resources = [];
      jsonData[key].resources.forEach((resource) => {
        let newResource = resourceTemplate.clone();
        let resourceName = keys(resource)[0]; // get first key
        let resourceAddress = resource[resourceName].address;
        let valuesArr = resource[resourceName].values;
        let valueObject = {};
        // For each value
        valuesArr.forEach((value) => {
          let valueKey = keys(value)[0];
          valueObject[valueKey] = value[valueKey];
        });
        resources.push(
          newResource.fill(
            resourceName,
            resourceAddress,
            matchSpace(1, prettyJSON(valueObject))
          )
        );
      });
      newModule.set("$VALUES", matchSpace(1, resources.join("\n")));
      strData += "\n" + newModule.str;
    });
    return strData.replace(/\n\s*\n+/g, "\n").replace(/;\n(?=tfx)/g, ";\n\n");
  },
};

module.exports = extract;
